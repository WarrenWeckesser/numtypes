//
// Signed integers with the most negative value treated as NAN.
//
// Requires C99.
// Python 3 only.
//

#define PY_SSIZE_T_CLEAN
#include <Python.h>

#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <stdbool.h>
#include <math.h>
#include <structmember.h>

#define NPY_NO_DEPRECATED_API NPY_API_VERSION
#include <numpy/arrayobject.h>
#include <numpy/arrayscalars.h>
#include <numpy/ufuncobject.h>
#include <numpy/halffloat.h>


// ========================================================================
// Signed integers with the most negative value treated as NAN.
// ========================================================================


static inline int32_t
nint32_neg(int32_t x) {
    return -x;
}


static inline int32_t
nint32_abs(int32_t x) {
    if (x >= 0) {
        return x;
    }
    else {
        return -x;
    }
}


static inline int32_t
nint32_add(int32_t x, int32_t y, bool *overflow) {
    if ((x == INT32_MIN) || (y == INT32_MIN)) {
        return INT32_MIN;
    }
    if ((x > 0 && y > INT32_MAX - x) || (x < 0 && y < INT32_MIN + 1 - x)) {
        *overflow = true;
    }
    return x + y;
}


static inline int32_t
nint32_subtract(int32_t x, int32_t y, bool *overflow) {
    if ((x == INT32_MIN) || (y == INT32_MIN)) {
        return INT32_MIN;
    }
    if ((x > 0 && y < INT32_MIN + 1 + x) || (x < 0 && y > INT32_MAX + x)) {
        *overflow = true;
    }
    return x - y;
}


static inline int32_t
nint32_multiply(int32_t x, int32_t y, bool *overflow)
{
    if ((x == INT32_MIN) || (y == INT32_MIN)) {
        return INT32_MIN;
    }
    if ((x == 0) || (y == 0)) {
        return 0;
    }
    if (nint32_abs(x) > (INT32_MAX / nint32_abs(y))) {
        *overflow = true;
    }
    return x * y;
}


// integer floor division: truncate towards -inf
// (like Python, not C)

static inline int32_t
nint32_floor_divide(int32_t x, int32_t y, bool *zero_division) {
    int32_t q;

    if ((x == INT32_MIN) || (y == INT32_MIN)) {
        return INT32_MIN;
    }
    if (y == 0) {
        *zero_division = true;
        return INT32_MIN;
    }

    if (y < 0) {
        y = -y;
        x = -x;
    }
    q = x / y;
    if ((x < 0) && (y*q != x)) {
        --q;
    }
    return q;
}


static inline double
nint32_true_divide(int32_t x, int32_t y, bool *zero_division) {
    if ((x == INT32_MIN) || (y == INT32_MIN)) {
        return NAN;
    }
    if (y == 0) {
        *zero_division = true;
        return NAN;  // XXX or something else?
    }
    return (double) x / y;
}


static inline int32_t
nint32_remainder(int32_t x, int32_t y, bool *zero_division) {
    if ((x == INT32_MIN) || (y == INT32_MIN)) {
        return INT32_MIN;
    }
    if (y == 0) {
        *zero_division = true;
        return INT32_MIN;
    }
    // XXX Check that this agrees with the expected behavior in Python
    // with respect to the signs of x and y.
    return x % y;
}


//
// XXX nint32_sign returns int32_t, so that it can return NAN when
// the input is NAN.  Will this actually work?
//

static inline int32_t
nint32_sign(int32_t x) {
    if (x == INT32_MIN) {
        return x;
    }
    return (x == 0 ? 0 : (x > 0 ? 1 : -1));
}


static inline int
nint32_eq(int32_t x, int32_t y) {
    if ((x == INT32_MIN) || (y == INT32_MIN)) {
        return 0;
    }
    return x == y;
}


static inline int
nint32_ne(int32_t x, int32_t y) {
    return !nint32_eq(x, y);
}


static inline int
nint32_lt(int32_t x, int32_t y) {
    if ((x == INT32_MIN) || (y == INT32_MIN)) {
        return 0;
    }
    return x < y;
}


static inline int
nint32_gt(int32_t x, int32_t y) {
    if ((x == INT32_MIN) || (y == INT32_MIN)) {
        return 0;
    }
    return x > y;
}


static inline int
nint32_le(int32_t x, int32_t y) {
    if ((x == INT32_MIN) || (y == INT32_MIN)) {
        return 0;
    }
    return x <= y;
}


static inline int
nint32_ge(int32_t x, int32_t y) {
    if ((x == INT32_MIN) || (y == INT32_MIN)) {
        return 0;
    }
    return x >= y;   
}

static inline float
nint32_as_float(int32_t x) {
    if (x == INT32_MIN) {
        return (float) NAN;
    }
    return (float) x;
}

static inline double
nint32_as_double(int32_t x) {
    if (x == INT32_MIN) {
        return (double) NAN;
    }
    return (double) x;
}

static inline int32_t
nint32_as_int32_t(int32_t x) {
    return x;
}

static inline int64_t
nint32_as_int64_t(int32_t x) {
    return (int64_t) x;
}

static inline int
nint32_nonzero(int32_t x) {
    return x != 0;
}


// ========================================================================
// Create a Python type.
// ========================================================================


typedef struct {
    PyObject_HEAD
    int32_t value;
} PyNInt32;


// Forward declaration.
static PyTypeObject PyNInt32_Type;


static inline int
PyNInt32_Check(PyObject* object) {
    return PyObject_IsInstance(object, (PyObject*) &PyNInt32_Type);
}


static PyObject*
PyNInt32_FromInt32(int32_t x) {
    PyNInt32* p = (PyNInt32*) PyNInt32_Type.tp_alloc(&PyNInt32_Type, 0);
    if (p) {
        p->value = x;
    }
    return (PyObject*) p;
}


static int
init_argument_error(void)
{
    PyErr_SetString(PyExc_TypeError,
                    "nint32() argument must be an integer, "
                    "a floating point nan, a string, "
                    "or another nint32 instance.");
    return -1;
}


static int
PyNInt32_init(PyNInt32 *self, PyObject *args, PyObject *kwds)
{
    static char *kwlist[] = {"value", NULL};
    PyObject *obj;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &obj)) {
        return -1;
    }
    Py_INCREF(obj);

    if (PyNInt32_Check(obj)) {
        self->value = ((PyNInt32 *) obj)->value;
        Py_DECREF(obj);
        return 0;
    }

    if (PyUnicode_Check(obj)) {
        // Argument is a string.
        // Try to convert it to a Python integer.
        PyObject *tmp = PyLong_FromUnicodeObject(obj, 10);
        if (tmp != NULL) {
            Py_DECREF(obj);
            obj = tmp;  // obj is now a Python integer.
        }
        else {
            // Conversion to an integer failed, now try to convert to a float.
            // The only float that is allowed is nan, but we check for this
            // below.  (Converting to float instead of doing a string
            // comparision with "nan" ensures that the conversion accepts the
            // same variations of the string "nan" as the builtin float() does,
            //  e.g "NaN", "nAn", "-NAN", "  +naN\t", etc.)
            PyErr_Clear();
            tmp = PyFloat_FromString(obj);
            Py_DECREF(obj);
            if (tmp == NULL) {
                PyErr_Clear();
                return init_argument_error();
            }
            obj = tmp;  // obj is now a Python float.
        }
    }
    else if (PyIndex_Check(obj)) {
        PyObject *tmp = PyNumber_Index(obj);
        Py_DECREF(obj);
        if (tmp == NULL) {
            // This can happen with a numpy array, e.g.
            // >>> nint32(np.array([123]))
            return -1;
        }
        obj = tmp;
    }

    if (PyLong_Check(obj)) {
        long long value = PyLong_AsLongLong(obj);
        Py_DECREF(obj);
        if (PyErr_Occurred()) {
            return -1;
        }
        if ((value <= INT32_MIN) || (value > INT32_MAX)) {
            PyErr_SetString(PyExc_OverflowError, "int too big to convert");
            return -1;
        }
        self->value = (int32_t) value;
        return 0;
    }

    if (PyFloat_Check(obj)) {
        double value = PyFloat_AsDouble(obj);
        Py_DECREF(obj);
        if (!isnan(value)) {
            return init_argument_error();
        }
        self->value = INT32_MIN;
        return 0;
    }

    Py_DECREF(obj);
    return init_argument_error();
}


static PyObject*
pynint32_richcompare(PyObject* a, PyObject* b, int op)
{
    // This check relies on knowing Py_LT is 0 (the lowest value)
    // and Py_GE is 5 (the greatest value).
    if ((op < Py_LT) || (op > Py_GE)) {
        PyErr_SetString(PyExc_ValueError, "invalid comparison op");
        return NULL;
    }
    if (Py_TYPE(a) == &PyNInt32_Type && Py_TYPE(b) == &PyNInt32_Type) {
        int result;
        if (((PyNInt32 *) a)->value == INT32_MIN || ((PyNInt32 *) b)->value == INT32_MIN) {
            // One of the values is nint32('nan').
            if (op == Py_NE) {
                Py_INCREF(Py_True);
                return Py_True;
            }
            else {
                Py_INCREF(Py_False);
                return Py_False;
            }
        }
        switch (op) {
            case Py_EQ: result = ((PyNInt32 *) a)->value == ((PyNInt32 *) b)->value; break;
            case Py_LT: result = ((PyNInt32 *) a)->value <  ((PyNInt32 *) b)->value; break;
            case Py_LE: result = ((PyNInt32 *) a)->value <= ((PyNInt32 *) b)->value; break;
            case Py_NE: result = ((PyNInt32 *) a)->value != ((PyNInt32 *) b)->value; break;
            case Py_GT: result = ((PyNInt32 *) a)->value >  ((PyNInt32 *) b)->value; break;
            case Py_GE: result = ((PyNInt32 *) a)->value >= ((PyNInt32 *) b)->value; break;
        };
        return PyBool_FromLong(result);
    }

    if (Py_TYPE(a) != &PyNInt32_Type) {
        PyNInt32 *p = (PyNInt32 *) b;
        PyObject *converted_b;
        if (p->value == INT32_MIN) {
            converted_b = PyFloat_FromDouble(NAN);
        }
        else {
            converted_b = PyLong_FromSsize_t((Py_ssize_t) p->value);
        }
        if (converted_b == NULL) {
            // Failed to convert a PyNInt32 to a Python integer or a
            // float nan--maybe a MemoryError?
            return NULL;
        }
        return PyObject_RichCompare(a, converted_b, op);
    }
    else {
        PyNInt32 *p = (PyNInt32 *) a;
        PyObject *converted_a;
        if (p->value == INT32_MIN) {
            converted_a = PyFloat_FromDouble(NAN);
        }
        else {
            converted_a = PyLong_FromSsize_t((Py_ssize_t) p->value);
        }
        if (converted_a == NULL) {
            // Failed to convert a PyNInt32 to a Python integer or a
            // float nan--maybe a MemoryError?
            return NULL;
        }
        return PyObject_RichCompare(converted_a, b, op);
    }
}


static PyObject*
pynint32_repr(PyObject* self) {
    int32_t value = ((PyNInt32*) self)->value;
    if (value == INT32_MIN) {
        return PyUnicode_FromString("nint32('nan')");
    }
    else {
        return PyUnicode_FromFormat("nint32(%" PRId32 ")", value);
    }
}

static PyObject*
pynint32_str(PyObject* self) {
    int32_t value = ((PyNInt32*) self)->value;
    if (value == INT32_MIN) {
        return PyUnicode_FromString("nan");
    }
    else {
        return PyUnicode_FromFormat("%" PRId32, value);
    }
}


static Py_hash_t
pynint32_hash(PyObject* self) {
    int32_t value = ((PyNInt32*) self)->value;
    // FIXME: What is a reasonable hash function?
    Py_hash_t h = 131071 * value;
    /* Never return the special error value -1 */
    return h == -1 ? 2 : h;
}


// ------------------------------------------------------------------------
// Unary number methods
// ------------------------------------------------------------------------


static PyObject *
pynint32_nb_int(PyNInt32 *o) {
    if (o->value == INT32_MIN) {
        PyErr_SetString(PyExc_ValueError,
                        "cannot convert nint32('nan') to integer");
        return NULL;
    }
    else {
        PyObject *result = PyLong_FromLong((long) o->value);
        return result;
    }
}

// This implementation of nb_index might not be valid.  It raises
// a TypeError if the argument is the integer nan, but shouldn't a
// ValueError be raised for such a specific value?  The fact the
// the documentation says that a TypeError should be raised on
// failure suggests that the intent is that *any* instance of an
// nint32 should be a valid index.  If that is the case, this
// function should not be implemented.
static PyObject *
pynint32_nb_index(PyNInt32 *o) {
    if (o->value == INT32_MIN) {
        PyErr_SetString(PyExc_TypeError,
                        "nint32('nan') cannot be interpreted as an integer");
        return NULL;
    }
    else {
        PyObject *result = PyLong_FromLong((long) o->value);
        return result;
    }
}

static PyObject *
pynint32_nb_float(PyNInt32 *o) {
    PyObject *result;
    double dval;

    dval = (o->value == INT32_MIN) ? NAN : (double) o->value;
    result = PyFloat_FromDouble(dval);
    return result;
}


static PyObject *
pynint32_nb_negative(PyNInt32 *o) {
    PyNInt32 *result = (PyNInt32 *) PyNInt32_Type.tp_alloc(&PyNInt32_Type, 0);
    result->value = nint32_neg(o->value);
    // XXX INCREF???
    return (PyObject *) result;
}


static PyObject *
pynint32_nb_positive(PyNInt32 *o) {
    return (PyObject *) o;
}


static PyObject *
pynint32_nb_absolute(PyNInt32 *o) {
    return (PyObject *) PyNInt32_FromInt32(nint32_abs(((PyNInt32 *) o)->value));
}


static int
pynint32_nb_bool(PyNInt32 *o) {
    return o->value != 0;
}


// ------------------------------------------------------------------------
// Binary number methods
// ------------------------------------------------------------------------

// XXX This implementation could be simplified if we handle casting similar
// to how it is done in pynint32_nb_true_divide.  That is, for a mixed
// expression nint32 + other, where other is not a nint32, convert the nint32
// to either a Python integer or a floating point nan, and do the addition with
// the converted object.  But that would mean that, for example, nint32(5) + 1
// would return the Python integer 6, not nint32(6), and nint32('nan') + 1
// would return a Python float nan, not nint32('nan').

static PyObject *
pynint32_nb_add(PyObject *o1, PyObject *o2)
{
    if ((Py_TYPE(o1) == &PyNInt32_Type) && (Py_TYPE(o2) == &PyNInt32_Type)) {
        // Both arguments are nint32.
        bool overflow = false;
        int32_t value = nint32_add(((PyNInt32 *) o1)->value, ((PyNInt32 *) o2)->value, &overflow);
        if (overflow) {
            PyErr_SetString(PyExc_OverflowError, "result exceeds limits of nint32");
            return NULL;
        }
        else {
            return (PyObject *) PyNInt32_FromInt32(value);
        }
    }

    if (Py_TYPE(o1) != &PyNInt32_Type) {
        PyObject *tmp = o1;
        o1 = o2;
        o2 = tmp;
    }

    if (!PyNumber_Check(o2)) {
        // The other argument is not a number.
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

    if (PyFloat_Check(o2)) {
        // The other argument is a float, so cast the first argument to
        // a C double, and return a Python float.
        double value1 = nint32_as_double(((PyNInt32 *) o1)->value);
        return (PyObject *) PyFloat_FromDouble(value1 + PyFloat_AsDouble(o2));
    }

    // Try to convert the other argument to a C long long integer.
    long long value2 = PyLong_AsLongLong(o2);
    if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            PyErr_Clear();
            Py_INCREF(Py_NotImplemented);
            return Py_NotImplemented;
        }
        else {
            return NULL;
        }
    }

    if ((value2 <= INT32_MIN) || (value2 > INT32_MAX)) {
        PyErr_SetString(PyExc_OverflowError, "operand exceeds limits of nint32");
        return NULL;        
    }

    bool overflow = false;
    int32_t value = nint32_add(((PyNInt32 *) o1)->value, value2, &overflow);
    if (overflow) {
        PyErr_SetString(PyExc_OverflowError, "result exceeds limits of nint32");
        return NULL;
    }

    return (PyObject *) PyNInt32_FromInt32(value);
}


static PyObject *
pynint32_nb_subtract(PyObject *o1, PyObject *o2)
{
    if ((Py_TYPE(o1) == &PyNInt32_Type) && (Py_TYPE(o2) == &PyNInt32_Type)) {
        // Both arguments are nint32.
        bool overflow = false;
        int32_t value = nint32_subtract(((PyNInt32 *) o1)->value, ((PyNInt32 *) o2)->value, &overflow);
        if (overflow) {
            PyErr_SetString(PyExc_OverflowError, "result exceeds limits of nint32");
            return NULL;
        }
        else {
            return (PyObject *) PyNInt32_FromInt32(value);
        }
    }

    if (Py_TYPE(o1) != &PyNInt32_Type) {
        // The first argument is not an nint32, so o2 must be an nint32.
        // Convert o2 to a standard Python type (either an integer or a floating
        // point nan), and call PyNumber_Subtract with the converted object.
        int32_t value2 = ((PyNInt32 *) o2)->value;
        PyObject *v2 = (value2 == INT32_MIN)
                        ? PyFloat_FromDouble(NAN)
                        : PyLong_FromLongLong((long long) value2);
        return PyNumber_Subtract(o1, v2);
    }
    else {
        // o1 is an nint32, o2 is not.
        int32_t value1 = ((PyNInt32 *) o1)->value;
        PyObject *v1 = (value1 == INT32_MIN)
                        ? PyFloat_FromDouble(NAN)
                        : PyLong_FromLongLong((long long) value1);
        return PyNumber_Subtract(v1, o2);
    }
}


static PyObject *
pynint32_nb_multiply(PyObject *o1, PyObject *o2)
{
    if ((Py_TYPE(o1) == &PyNInt32_Type) && (Py_TYPE(o2) == &PyNInt32_Type)) {
        // Both arguments are nint32.
        bool overflow = false;
        int32_t value = nint32_multiply(((PyNInt32 *) o1)->value, ((PyNInt32 *) o2)->value, &overflow);
        if (overflow) {
            PyErr_SetString(PyExc_OverflowError, "result exceeds limits of nint32");
            return NULL;
        }
        else {
            return (PyObject *) PyNInt32_FromInt32(value);
        }
    }

    if (Py_TYPE(o1) != &PyNInt32_Type) {
        PyObject *tmp = o1;
        o1 = o2;
        o2 = tmp;
    }

    if (!PyNumber_Check(o2)) {
        // The other argument is not a number.
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

    if (PyFloat_Check(o2)) {
        // The other argument is a float, so cast the first argument to
        // a C double, and return a Python float.
        double value1 = nint32_as_double(((PyNInt32 *) o1)->value);
        // XXX Check for floating point overflow or underflow?
        return (PyObject *) PyFloat_FromDouble(value1 * PyFloat_AsDouble(o2));
    }

    // Try to convert the other argument to a C long long integer.
    long long value2 = PyLong_AsLongLong(o2);
    if (PyErr_Occurred()) {
        if (PyErr_ExceptionMatches(PyExc_TypeError)) {
            PyErr_Clear();
            Py_INCREF(Py_NotImplemented);
            return Py_NotImplemented;
        }
        else {
            return NULL;
        }
    }

    if ((value2 <= INT32_MIN) || (value2 > INT32_MAX)) {
        PyErr_SetString(PyExc_OverflowError, "operand exceeds limits of nint32");
        return NULL;        
    }

    bool overflow = false;
    int32_t value = nint32_multiply(((PyNInt32 *) o1)->value, value2, &overflow);
    if (overflow) {
        PyErr_SetString(PyExc_OverflowError, "result exceeds limits of nint32");
        return NULL;
    }

    return (PyObject *) PyNInt32_FromInt32(value);
}


static PyObject *
pynint32_nb_floor_divide(PyObject *o1, PyObject *o2)
{
    if ((Py_TYPE(o1) == &PyNInt32_Type) && (Py_TYPE(o2) == &PyNInt32_Type)) {
        // Both arguments are nint32.
        bool zero_division = false;
        int32_t value = nint32_floor_divide(((PyNInt32 *) o1)->value, ((PyNInt32 *) o2)->value, &zero_division);
        if (zero_division) {
            PyErr_SetString(PyExc_ZeroDivisionError, "division by zero");
            return NULL;
        }
        else {
            return (PyObject *) PyNInt32_FromInt32(value);
        }
    }

    if (Py_TYPE(o1) != &PyNInt32_Type) {
        // The first argument is not an nint32, so o2 must be an nint32.
        // Convert o2 to a standard Python type (either an integer or a floating
        // point nan), and call PyNumber_Subtract with the converted object.
        int32_t value2 = ((PyNInt32 *) o2)->value;
        PyObject *v2 = (value2 == INT32_MIN)
                        ? PyFloat_FromDouble(NAN)
                        : PyLong_FromLongLong((long long) value2);
        return PyNumber_FloorDivide(o1, v2);
    }
    else {
        // o1 is an nint32, o2 is not.
        int32_t value1 = ((PyNInt32 *) o1)->value;
        PyObject *v1 = (value1 == INT32_MIN)
                        ? PyFloat_FromDouble(NAN)
                        : PyLong_FromLongLong((long long) value1);
        return PyNumber_FloorDivide(v1, o2);
    }
}


static PyObject *
pynint32_nb_true_divide(PyObject *o1, PyObject *o2)
{
    if ((Py_TYPE(o1) == &PyNInt32_Type) && (Py_TYPE(o2) == &PyNInt32_Type)) {
        // Both arguments are nint32.
        bool zero_division = false;
        double value = nint32_true_divide(((PyNInt32 *) o1)->value, ((PyNInt32 *) o2)->value, &zero_division);
        if (zero_division) {
            PyErr_SetString(PyExc_ZeroDivisionError, "division by zero");
            return NULL;
        }
        else {
            return (PyObject *) PyFloat_FromDouble(value);
        }
    }

    if (Py_TYPE(o1) != &PyNInt32_Type) {
        // The first argument is not an nint32, so o2 must be an nint32.
        // Convert o2 to a standard Python type (either an integer or a floating
        // point nan), and call PyNumber_TrueDivde with the converted object.
        int32_t value2 = ((PyNInt32 *) o2)->value;
        PyObject *v2 = (value2 == INT32_MIN)
                        ? PyFloat_FromDouble(NAN)
                        : PyLong_FromLongLong((long long) value2);
        return PyNumber_TrueDivide(o1, v2);
    }
    else {
        // o1 is an nint32, o2 is not.
        int32_t value1 = ((PyNInt32 *) o1)->value;
        PyObject *v1 = (value1 == INT32_MIN)
                        ? PyFloat_FromDouble(NAN)
                        : PyLong_FromLongLong((long long) value1);
        return PyNumber_TrueDivide(v1, o2);
    }
}


// Python number protocol methods for nint32.

static PyNumberMethods pynint32_as_number = {
    .nb_add          = pynint32_nb_add,
    .nb_subtract     = pynint32_nb_subtract,
    .nb_multiply     = pynint32_nb_multiply,
    .nb_negative     = (unaryfunc) pynint32_nb_negative,
    .nb_positive     = (unaryfunc) pynint32_nb_positive,
    .nb_absolute     = (unaryfunc) pynint32_nb_absolute,
    .nb_bool         = (inquiry) pynint32_nb_bool,
    .nb_int          = (unaryfunc) pynint32_nb_int,
    .nb_float        = (unaryfunc) pynint32_nb_float,
    .nb_floor_divide = pynint32_nb_floor_divide,
    .nb_true_divide  = pynint32_nb_true_divide,
    .nb_index        = (unaryfunc) pynint32_nb_index,
};


// Python type object for nint32.

static PyTypeObject PyNInt32_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name        = "nint32",
    .tp_basicsize   = sizeof(PyNInt32),
    .tp_repr        = pynint32_repr,
    .tp_as_number   = &pynint32_as_number,
    .tp_hash        = pynint32_hash,
    .tp_str         = pynint32_str,
    .tp_flags       = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_doc         = "Fixed width integer with NAN value",
    .tp_richcompare = pynint32_richcompare,
    .tp_init        = (initproc) PyNInt32_init,
    .tp_new         = PyType_GenericNew,
};


PyMethodDef module_methods[] = {
    {0} // sentinel
};


static struct PyModuleDef moduledef = {
    .m_base     = PyModuleDef_HEAD_INIT,
    .m_name     = "_nint",
    .m_size     = -1,
    .m_methods  = module_methods,
};


// ========================================================================
// NumPy support.
// ========================================================================

// ------------------------------------------------------------------------
// Functions to be put in the PyArray_ArrFuncs structure.
// ------------------------------------------------------------------------

static PyObject*
npynint32_f_getitem(void* data, void* arr) {
    PyObject *p = (PyObject *) PyNInt32_FromInt32(*((int32_t *) data));
    return p;
}


// XXX Share the code in the following with PyNInt32_init.

static int
npynint32_f_setitem(PyObject* item, void* data, void* arr) {
    if (PyNInt32_Check(item)) {
        *((int32_t *)data) = ((PyNInt32 *) item)->value;
        return 0;
    }
    else {
        // item is some other Python object.
        // If it is a floating point nan, set the value to INT32_MIN.
        // Otherwise, cast to int and check the bounds.

        if (PyFloat_Check(item)) {
            // This handles np.float64 and Python floats.
            double value = PyFloat_AsDouble(item);
            if (isnan(value)) {
                *((int32_t *)data) = INT32_MIN;
                return 0;
            }
        }

        if (PyArray_IsScalar(item, Float)) {
            float value = ((PyFloatScalarObject *) item)->obval;
            if (isnan(value)) {
                *((int32_t *)data) = INT32_MIN;
                return 0;
            }
        }

        if (PyArray_IsScalar(item, LongDouble)) {
            long double value = ((PyLongDoubleScalarObject *) item)->obval;
            if (isnan(value)) {
                *((int32_t *)data) = INT32_MIN;
                return 0;
            }
        }

        if (PyArray_IsScalar(item, Half)) {
            npy_half value = ((PyLongDoubleScalarObject *) item)->obval;
            if (npy_half_isnan(value)) {
                *((int32_t *)data) = INT32_MIN;
                return 0;
            }
        }

        // Apparently the value in item is not a floating point nan...

        long long value = PyLong_AsLongLong(item);
        if (PyErr_Occurred()) {
            return -1;
        }

        if ((value <= INT32_MIN) || (value > INT32_MAX)) {
            PyErr_SetString(PyExc_OverflowError, "int too big to convert");
            return -1;
        }
        *(int32_t *)data = (int32_t) value;
        return 0;
    }
}


// XXX Not needed?
static inline void
byteswap(int32_t *x) {
    char *p = (char *) x;
    char *q = p + sizeof(*x);
    while (p < q) {
        char tmp = *p;
        --q;
        *p = *q;
        *q = tmp;
        ++p;
    }
}


static inline void
copyswap(int32_t *dst, int32_t *src) {
    char *from = (char *) src;
    char *to = (char *) (dst + 1);
    for (size_t i = 0; i < sizeof(int32_t); ++i) {
        --to;
        *to = *from;
        ++from;
    }
}


static void
npynint32_f_copyswap(void* dst, void* src, int swap, void* arr) {
    if (!src) {
        return;
    }
    if (swap) {
        copyswap((int32_t *) dst, (int32_t *) src);
    }
    else {
        *((int32_t *) dst) = *((int32_t *) src);
    }
}


static void
npynint32_f_copyswapn(void* dst_, npy_intp dstride,
                     void* src_, npy_intp sstride,
                     npy_intp n, int swap, void* arr) {
    char *dst = (char *) dst_;
    char *src = (char * )src_;
    if (!src) {
        return;
    }
    if (swap) {
        for (npy_intp i = 0; i < n; i++) {
            copyswap((int32_t *) dst, (int32_t *) src);
            dst += dstride;
            src += sstride;
        }
    }
    else if (dstride == sizeof(int32_t) && sstride == sizeof(int32_t)) {
        // Each array is contiguous, so we can use a single call to memcpy.
        memcpy(dst, src, n*sizeof(int32_t));
    }
    else {
        for (npy_intp i = 0; i < n; i++) {
            *((int32_t *) dst) = *((int32_t *) src);
            dst += dstride;
            src += sstride;
        }
    }
}


static npy_bool
npynint32_f_nonzero(void* data, void* arr) {
    return nint32_nonzero(*((int32_t *) data)) ? NPY_TRUE : NPY_FALSE;
}

// ------------------------------------------------------------------------
// Functions for casting from nint32 to NumPy builtin data types.
// These will be assigned to the appropriate slots in
// the array npynint32_arrfuncs.cast[].
// ------------------------------------------------------------------------

#define CAST_FUNC_TO_BASIC_TYPE(type) \
    static void \
    npy_cast_nint32_to_##type(void* from, void* to, npy_intp n, \
                              void* fromarr, void* toarr) \
    { \
        for (npy_intp i = 0; i < n; ++i) { \
            ((type *) to)[i] = nint32_as_##type(((int32_t *) from)[i]); \
        } \
    }

CAST_FUNC_TO_BASIC_TYPE(float)
CAST_FUNC_TO_BASIC_TYPE(double)
CAST_FUNC_TO_BASIC_TYPE(int32_t)
CAST_FUNC_TO_BASIC_TYPE(int64_t)


static PyArray_ArrFuncs npynint32_arrfuncs = {
    .getitem    = npynint32_f_getitem,
    .setitem    = npynint32_f_setitem,
    .copyswapn  = npynint32_f_copyswapn,
    .copyswap   = npynint32_f_copyswap,
    .nonzero    = npynint32_f_nonzero,
    .cast       = {[NPY_INT32]  = npy_cast_nint32_to_int32_t,
                   [NPY_INT64]  = npy_cast_nint32_to_int64_t,
                   [NPY_FLOAT]  = npy_cast_nint32_to_float,
                   [NPY_DOUBLE] = npy_cast_nint32_to_double},
};


PyArray_Descr npynint32_descr = {
    PyObject_HEAD_INIT(0)
    .typeobj    = &PyNInt32_Type,
    .kind       = 'x',
    .type       = 'x',
    .byteorder  = '=',
    /*
     * For now, we need NPY_NEEDS_PYAPI in order to make numpy detect our
     * exceptions.  This isn't technically necessary,
     * since we're careful about thread safety, and hopefully future
     * versions of numpy will recognize that.
     * XXX Is this still needed for the int32_t type?  Do we even
     * need NPY_USE_GETITEM and NPY_USE_SETITEM?
     */
    .flags      = NPY_NEEDS_PYAPI | NPY_USE_GETITEM | NPY_USE_SETITEM,
    .elsize     = sizeof(int32_t),
    .alignment  = offsetof(struct {char c; int32_t value;}, value),
    .f          = &npynint32_arrfuncs,
};


// ------------------------------------------------------------------------
// Functions for casting from NumPy builtin types to nint32.
// These will be registered with calls to PyArray_RegisterCanCast.
// ------------------------------------------------------------------------

// Casting from int64 to nint32 is probably not a great idea.
// The values will be cast modulo 2**32, so some valid int64 values
// might get converted to nint32('nan').  It might be better to
// not allow the conversion, so the user is forced to convert their
// data to a safe format first.
// For now, though, I'll implement it.
/***** UNUSED (for now)
static void
npy_cast_int64_to_nint32(void* from, void* to, npy_intp n,
                         void* fromarr, void* toarr)
{
    for (npy_intp i = 0; i < n; ++i) {
        ((int32_t *) to)[i] = ((int64_t *) from)[i];
    }
}
*****/

// This function is exactly the same as npy_cast_nint32_to_int32.
// For the moment, I'm working formally.  This can probably be removed later.
static void
npy_cast_int32_to_nint32(void* from, void* to, npy_intp n,
                         void* fromarr, void* toarr)
{
    for (npy_intp i = 0; i < n; ++i) {
        ((int32_t *) to)[i] = ((int32_t *) from)[i];
    }
}

static void
npy_cast_int16_to_nint32(void* from, void* to, npy_intp n,
                         void* fromarr, void* toarr)
{
    for (npy_intp i = 0; i < n; ++i) {
        ((int32_t *) to)[i] = ((int16_t *) from)[i];
    }
}

static void
npy_cast_uint16_to_nint32(void* from, void* to, npy_intp n,
                          void* fromarr, void* toarr)
{
    for (npy_intp i = 0; i < n; ++i) {
        ((int32_t *) to)[i] = ((uint16_t *) from)[i];
    }
}

static void
npy_cast_int8_to_nint32(void* from, void* to, npy_intp n,
                        void* fromarr, void* toarr)
{
    for (npy_intp i = 0; i < n; ++i) {
        ((int32_t *) to)[i] = ((int8_t *) from)[i];
    }
}

static void
npy_cast_uint8_to_nint32(void* from, void* to, npy_intp n,
                         void* fromarr, void* toarr)
{
    for (npy_intp i = 0; i < n; ++i) {
        ((int32_t *) to)[i] = ((uint8_t *) from)[i];
    }
}

static void
npy_cast_bool_to_nint32(void* from, void* to, npy_intp n,
                        void* fromarr, void* toarr)
{
    for (npy_intp i = 0; i < n; ++i) {
        ((int32_t *) to)[i] = ((int8_t *) from)[i] != 0;
    }
}

/***** UNUSED (for now)
static void
npy_cast_float_to_nint32(void* from, void* to, npy_intp n,
                         void* fromarr, void* toarr)
{
    for (npy_intp i = 0; i < n; ++i) {
        float from_value = ((float *) from)[i];
        ((int32_t *) to)[i] = isnan(from_value) ? INT32_MIN : (int32_t) from_value;
    }
}
*****/

/***** UNUSED (for now)
static void
npy_cast_double_to_nint32(void* from, void* to, npy_intp n,
                          void* fromarr, void* toarr)
{
    for (npy_intp i = 0; i < n; ++i) {
        double from_value = ((double *) from)[i];
        ((int32_t *) to)[i] = isnan(from_value) ? INT32_MIN : (int32_t) from_value;
    }
}
*****/

// ------------------------------------------------------------------------
// ufunc inner loop functions.
// ------------------------------------------------------------------------


#define BINARY_UFUNC(name)                                                  \
    void nint32_ufunc_##name(char** args, const npy_intp* dimensions,       \
                             const npy_intp* steps, void* data)             \
    {                                                                       \
        char *i0 = args[0];                                                 \
        char *i1 = args[1];                                                 \
        char  *o = args[2];                                                 \
                                                                            \
        npy_intp n = *dimensions;                                           \
                                                                            \
        npy_intp is0 = steps[0];                                            \
        npy_intp is1 = steps[1];                                            \
        npy_intp os = steps[2];                                             \
                                                                            \
        bool overflow = false;                                              \
                                                                            \
        for (npy_intp k = 0; k < n; k++, i0 += is0, i1 += is1, o += os) {   \
            int32_t x = *(int32_t *)i0;                                     \
            int32_t y = *(int32_t *)i1;                                     \
            *(int32_t *)o = nint32_##name(x, y, &overflow);                 \
        }                                                                   \
        if (overflow) {                                                     \
            NPY_ALLOW_C_API_DEF                                             \
            NPY_ALLOW_C_API                                                 \
            PyErr_SetString(PyExc_RuntimeError,                             \
                            "nint32 overflow during " #name);               \
            NPY_DISABLE_C_API                                               \
        }                                                                   \
    }

BINARY_UFUNC(add)
BINARY_UFUNC(subtract)
BINARY_UFUNC(multiply)
BINARY_UFUNC(floor_divide)


// ========================================================================
// Python extension module definition.
// ========================================================================

PyMODINIT_FUNC
PyInit__nint(void) {
    PyObject* m = NULL;
    PyObject* numpy_str;
    PyObject* numpy;
    int npy_nint32;
    int check;

    import_array();
    if (PyErr_Occurred()) {
        return NULL;
    }

    import_umath();
    if (PyErr_Occurred()) {
         return NULL;
    }

    numpy_str = PyUnicode_FromString("numpy");
    if (!numpy_str) {
        return NULL;
    }

    numpy = PyImport_Import(numpy_str);
    Py_DECREF(numpy_str);
    if (!numpy) {
        return NULL;
    }

    // ----------------------------------------------------------------
    // Set up the Python type nint32
    // ----------------------------------------------------------------

    // Can't set this until we import numpy
    PyNInt32_Type.tp_base = &PyGenericArrType_Type;

    // Initialize nint32 type object
    if (PyType_Ready(&PyNInt32_Type) < 0) {
        return NULL;
    }

    // ----------------------------------------------------------------
    // Set up the NumPy dtype
    // ----------------------------------------------------------------

    Py_TYPE(&npynint32_descr) = &PyArrayDescr_Type;
    npy_nint32 = PyArray_RegisterDataType(&npynint32_descr);
    if (npy_nint32 < 0) {
        return NULL;
    }

    // Support nint32.dtype
    if (PyDict_SetItemString(PyNInt32_Type.tp_dict, "dtype",
                             (PyObject*) &npynint32_descr) < 0) {
        return NULL;
    }

    // ----------------------------------------------------------------
    // Configure casting rules for the NumPy dtype.
    // Note: The casting functions for converting from nint32
    // to int32, int64, float and double are hard-coded into
    // the .cast field of the npynint32_arrfuncs structure
    // ----------------------------------------------------------------

    // This allows, for example,
    //     np.array([1, 2, 3], dtype=np.int32).astype(nint32)
    // to work.
    if (PyArray_RegisterCastFunc(PyArray_DescrFromType(NPY_INT32),
                                 npy_nint32,
                                 npy_cast_int32_to_nint32) < 0) {
        return NULL;
    }
    // This allows, for example,
    //     np.array([1, 2], dtype=nint32) + np.array([3, 4], dtype=np.int32)
    // to work--the np.int32 array is coerced to nint32 and the result has
    // dtype nint32.
    if (PyArray_RegisterCanCast(PyArray_DescrFromType(NPY_INT32),
                                npy_nint32,
                                NPY_NOSCALAR) < 0) {
        return NULL;
    }

    /*
    if (PyArray_RegisterCastFunc(PyArray_DescrFromType(NPY_INT64),
                                 npy_nint32,
                                 npy_cast_int64_to_nint32) < 0) {
        return NULL;
    }
    if (PyArray_RegisterCanCast(PyArray_DescrFromType(NPY_INT64),
                                npy_nint32,
                                NPY_NOSCALAR) < 0) {
        return NULL;
    }
    */

    if (PyArray_RegisterCastFunc(PyArray_DescrFromType(NPY_INT16),
                                 npy_nint32,
                                 npy_cast_int16_to_nint32) < 0) {
        return NULL;
    }
    if (PyArray_RegisterCanCast(PyArray_DescrFromType(NPY_INT16),
                                npy_nint32,
                                NPY_NOSCALAR) < 0) {
        return NULL;
    }

    if (PyArray_RegisterCastFunc(PyArray_DescrFromType(NPY_INT8),
                                 npy_nint32,
                                 npy_cast_int8_to_nint32) < 0) {
        return NULL;
    }
    if (PyArray_RegisterCanCast(PyArray_DescrFromType(NPY_INT8),
                                npy_nint32,
                                NPY_NOSCALAR) < 0) {
        return NULL;
    }


    if (PyArray_RegisterCastFunc(PyArray_DescrFromType(NPY_UINT8),
                                 npy_nint32,
                                 npy_cast_uint8_to_nint32) < 0) {
        return NULL;
    }
    if (PyArray_RegisterCanCast(PyArray_DescrFromType(NPY_UINT8),
                                npy_nint32,
                                NPY_NOSCALAR) < 0) {
        return NULL;
    }


    if (PyArray_RegisterCastFunc(PyArray_DescrFromType(NPY_UINT16),
                                 npy_nint32,
                                 npy_cast_uint16_to_nint32) < 0) {
        return NULL;
    }
    if (PyArray_RegisterCanCast(PyArray_DescrFromType(NPY_UINT16),
                                npy_nint32,
                                NPY_NOSCALAR) < 0) {
        return NULL;
    }

    if (PyArray_RegisterCastFunc(PyArray_DescrFromType(NPY_BOOL),
                                 npy_nint32,
                                 npy_cast_bool_to_nint32) < 0) {
        return NULL;
    }
    if (PyArray_RegisterCanCast(PyArray_DescrFromType(NPY_BOOL),
                                npy_nint32,
                                NPY_NOSCALAR) < 0) {
        return NULL;
    }


    if (PyArray_RegisterCanCast(&npynint32_descr,
                                NPY_FLOAT,
                                NPY_NOSCALAR) < 0) {
        return NULL;
    }
    if (PyArray_RegisterCanCast(&npynint32_descr,
                                NPY_DOUBLE,
                                NPY_NOSCALAR) < 0) {
        return NULL;
    }



    int binary_ufunc_types[] = {npy_nint32, npy_nint32, npy_nint32};

    #define REGISTER_BINARY_UFUNC(name) \
        PyUFuncObject* ufunc_##name = (PyUFuncObject*) PyObject_GetAttrString(numpy, #name); \
        if (!ufunc_##name) { \
            return NULL; \
        } \
        check = PyUFunc_RegisterLoopForType(ufunc_##name, npy_nint32, \
                                            nint32_ufunc_##name, \
                                            binary_ufunc_types, 0); \
        Py_DECREF(ufunc_##name); \
        if (check < 0) { \
            return NULL; \
        }

    REGISTER_BINARY_UFUNC(add)
    REGISTER_BINARY_UFUNC(subtract)
    REGISTER_BINARY_UFUNC(multiply)
    REGISTER_BINARY_UFUNC(floor_divide)


    // Create module
    m = PyModule_Create(&moduledef);
    if (!m) {
        return NULL;
    }

    // Add nint32 type
    Py_INCREF(&PyNInt32_Type);
    PyModule_AddObject(m, "nint32", (PyObject*) &PyNInt32_Type);

    return m;
}
